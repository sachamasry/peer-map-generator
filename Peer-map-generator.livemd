<!-- livebook:{"app_settings":{"output_type":"rich","slug":"peer-map-generator","zero_downtime":true},"autosave_interval_s":60,"file_entries":[{"name":"peer_map_file.xlsx","type":"attachment"}],"persist_outputs":true} -->

# Generate Peer Map from Spreadsheet

```elixir
Mix.install([
  {:kino, "~> 0.11.2"},
  {:faker, "~> 0.17.0"},
  {:kino_vega_lite, "~> 0.1.10"},
  {:xlsx_reader, "~> 0.7.0"}
])
```

## Synopsis

This small application reads an `.xlsx` formatted spreadsheet, generating a [Mermaid](https://mermaid.js.org/) diagram. The default Mermaid diagram is displayed in the app as a visual verification tool, helping ensure all the data is present—and correct—in the input spreadhseet. Additionally, the program displays the code defining the diagram, which can be copied into any tool which understands Mermaid flowchart definitions, such as [Draw.io](https://www.drawio.com/).

The nodes and relationships are automatically laid out by Mermaid's algorithms, this however is often not really presentable, especially in diagrams with many entities. This is where Draw.io helps, as you can import this code into the program and graphically manipulate its flowchart elements and relationships, laying out, grouping and styling it in an aesthetically-pleasing and presentable way.

## Background and motivation

The drive for this solution came from the need to easily create and present _peer maps_, visual diagrams presenting groups of teenagers, their relationships and interactions, to identify individuals at risk, and come up with a strategy to help them.

Despite information existing in various records—databases, spreadsheets, and other documents—it is difficult to spot deep patterns in raw data. Humans are excellent at manipulating objects and making new inferences from visual data, which is why peer mapping is used as a tool to help identify where help is needed. Flowcharting and diagramming software exists to provide a common visual language to manipulate, then share information.

<!-- livebook:{"break_markdown":true} -->

### Why not build a diagram manually?

While it is easy to build a flowchart in any diagramming software program—including Draw.io—the work needed to create the flowchart with all the data needed is extremely tedious and quite error-prone. For example, a medium-complexity diagram involving only a dozen people, a few locations, each with one relationship or interaction, and several _groupings_, will demand much copying (and pasting):

<!-- livebook:{"break_markdown":true} -->

* $12\times2=24$ facts for entities: twelve people or places, two facts per entity, e.g. name and age
* $3\times3=9$ facts for groupings: incidents, places (street, estates, schools), gangs or affiliations, with three facts per group, e.g. title, comments, objects belonging to groups
* $16\times2=32$ facts for relationships and incidents: how people are related to each other, with comments, who was involved in incidents with description, date and place

<!-- livebook:{"break_markdown":true} -->

This example showss that a diagram built by hand needs 65 facts copied from some source data, then pasted into the diagram, needing at least 130 interactions (once to copyŵand the second time to paste), ignoring context-switching, searching and other tasks. All of this is needed just to _place_ the information on the canvas, _before_ it is rearranged and styled for presentation, a process which can easily take half an hour as it is reasonable to expect at most two copy and paste operations in a minute. The result is one single diagram, when several may be required. Clearly, the cost of doing this manually is rather high and should be automated, where possible.

<!-- livebook:{"break_markdown":true} -->

By co-locating all the relevant data into a spreadsheet, using automation to build up a _base_ diagram, much tedium can be avoided. It is important to note that this information already exists in spreadsheets, so that preparing the data according to a template shouldn't take very much time. Once it is ready, this Livebook can read and convert the data into a structured form to help construct a diagram. This diagram is a starting point, with all the facts already inserted, ready and waiting to be styled.

## The process

This Livebook acts as a very simple web application, used to select the input spreadsheet and generate the data needed for a flowchart. When run, it presents a minimalist user interface, asking only for the input spreadsheet's location.

<!-- livebook:{"break_markdown":true} -->

The process expected here is that a complying spreadsheet is created, opened and read inside this Livebook, and the resulting automatic Mermaid diagram inspected. One of the principal benefits of a Mermaid diagram is delegating layout to the software. Mermaid can produce a good layout with a simple diagram, especially one with few relationships, but is unsuitable for any large or complex data sets. For this reason, the automatically-generated diagram is nothing more than a way to check that all information has been read and included correctly. If anything is seen to be wrong at this stage, corrections should be made in the spreadsheet and the process repeated, until the diagram shows all desired data.

See the flowchart below for a graphical representation of the steps in the process.

```elixir
Kino.Mermaid.new("""
flowchart TD
  A[Prepare spreadsheet]
  B[Run this Livebook]
  DIACHECK{Is all data <br />on the diagram <br />and correct?}
  C[Copy generated <br />diagram code]
  D[Import into Draw.io]
  E[Lay out and style <br />diagram for presentation]
  
  A--Open spreadsheet for reading <br />in Livebook app-->B
  B--Check automatically <br />generated diagram-->DIACHECK
  DIACHECK--Yes-->C
  DIACHECK--No-->A
  C-->D
  D-->E
""")
```

<!-- livebook:{"output":true} -->

```mermaid
flowchart TD
  A[Prepare spreadsheet]
  B[Run this Livebook]
  DIACHECK{Is all data <br />on the diagram <br />and correct?}
  C[Copy generated <br />diagram code]
  D[Import into Draw.io]
  E[Lay out and style <br />diagram for presentation]
  
  A--Open spreadsheet for reading <br />in Livebook app-->B
  B--Check automatically <br />generated diagram-->DIACHECK
  DIACHECK--Yes-->C
  DIACHECK--No-->A
  C-->D
  D-->E

```

Once the diagram shows all the expected data, copy the diagram-defining code displayed underneath, and import that into a blank diagram in Draw.io: click on the 'Insert' button in the menu bar (`+` icon) `>` select `Advanced` `>` select the `Mermaid` option. Delete any text in the text box, paste the copied diagram definition and click `Insert`. You will see a newly created diagram on the canvas.

Now that all the data has been converted into a diagram, all that needs to be done is to create a layout adhering to the accepted in-house style, where all the people and relationships have been placed in a way that presents information in a grouped way. This is not an objective process, needing to be done in a way that stimulates discussion and pattern-recognition, to aid drawing impactful conclusions from the data.

<!-- livebook:{"break_markdown":true} -->

### Going further

Draw.io is free and open-source software, and is very powerful, in which it is possible to create powerful diagrams. Even though it is widely used, often it is only the more well-known commercial competitors that are available at an institution, with which practitioners have more experience.

Some popular, commercial diagramming software is able to import Draw.io files (`.drawio` extension), and these can be a good substitute for Draw.io in the steps above. [Lucidchart](https://lucidchart.com) is one example of excellent diagramming software. Following the above step of importing the Mermaid chart into Draw.io, save the diagram to a file, then import the new `.drawio` file into Lucidchart, to do the layout and final styling of the diagram in Lucidchart exclusively.

## Reading from Excel spreadsheet

Spreadsheets are a commonly-used tool, and are the simplest way for practitioners to enter data in preparation for peer mapping, and an easy and structured data source for a program to read from. Within the spreadsheet, _worksheets_ act as two-dimensional tables, storing records of people, their relationships and interactions to be mapped.

```elixir
defmodule Graphing.Spreadsheet do
  def open_spreadsheet_file(file_location) do
    {:ok, package} =
      XlsxReader.open(file_location, supported_custom_formats: [{}])

    package
  end

  def read_all_worksheets(xlsx_data_payload) do
    {:ok, data} =
      XlsxReader.sheets(xlsx_data_payload,
        except: "Configuration",
        skip_row?: fn [column | _] -> column == :expect_chars or column == "" end,
        empty_rows: false,
        blank_value: "",
        number_type: Integer
      )

    data
  end

  def get_payload(data_payload, worksheet) do
    [
      {"People", [_people_headers | people_list]},
      {"Groupings", [_grouping_headers | groupings_list]},
      {"Relationships", [_relationship_headers | relationships_list]} | _
    ] = data_payload

    case worksheet do
      "People" -> people_list
      "Groupings" -> groupings_list
      "Relationships" -> relationships_list
      _ -> people_list
    end
  end
end
```

```elixir
defmodule Person do
  defstruct id: 0, name: "", dob: "", belongs_to_subgraph: []
end
```

```elixir
defmodule Graphing.People do
  defp contained_by_to_list(contained_by_string) when is_bitstring(contained_by_string) do
    contained_by_string
    |> to_string()
    |> String.trim()
    |> String.split("|")
    |> Enum.filter(fn i -> i != "" end)
    |> Enum.map(fn i -> String.to_integer(i) end)
  end

  def parse_people(people_list) when is_list(people_list) do
    people_list
    |> Enum.map(fn [id, name, surname, contained_by, dob | _] ->
      %Person{
        id: String.to_integer(id),
        name: name <> " " <> surname,
        dob: dob,
        belongs_to_subgraph: contained_by_to_list(contained_by)
      }
    end)
  end

  def top_level_people(people_list) when is_list(people_list) do
    people_list
    |> Enum.filter(fn i ->
      Map.get(i, :belongs_to_subgraph) == []
    end)
  end

  def contained_people(people_list) when is_list(people_list) do
    people_list
    |> Enum.filter(fn i ->
      is_list(Map.get(i, :belongs_to_subgraph)) and
        length(Map.get(i, :belongs_to_subgraph)) > 0
    end)
  end

  def people_contained_by(people_list, container_id)
      when is_list(people_list) and is_integer(container_id) do
    people_list
    |> Enum.filter(fn i ->
      Enum.member?(Map.get(i, :belongs_to_subgraph), container_id)
    end)
  end
end
```

```elixir
defmodule Subgraph do
  defstruct id: 0, title: "", children: [], people: []
end
```

```elixir
defmodule Graphing.SubgraphReader do
  def top_level_subgraphs(subgraph_list) when is_list(subgraph_list) do
    subgraph_list |> Enum.filter(fn [_id, _title, contained_by] -> contained_by == 0 end)
  end

  def child_subgraphs(subgraph_list) when is_list(subgraph_list) do
    subgraph_list |> Enum.filter(fn [_id, _title, contained_by] -> contained_by > 0 end)
  end

  def subgraphs(subgraph_list, id) when is_list(subgraph_list) and is_integer(id) do
    subgraph_list |> Enum.filter(fn [_id, _title, contained_by] -> contained_by == id end)
  end
end
```

```elixir
defmodule Graphing.Subgraphs.Tree do
  def construct_subgraph_tree(subgraph_list, people_list \\ [])
      when is_list(subgraph_list) and is_list(people_list) do
    do_construct_subgraph_tree(subgraph_list, subgraph_list, people_list, [], 0)
  end

  defp do_construct_subgraph_tree(_full_subgraph_list, [], _people_list, acc, _parent_id), do: acc

  defp do_construct_subgraph_tree(
         full_subgraph_list,
         [[id, title, contained_by] | tail],
         people_list,
         acc,
         parent_id
       )
       when contained_by == parent_id do
    do_construct_subgraph_tree(
      full_subgraph_list,
      tail,
      people_list,
      [
        %Subgraph{
          id: id,
          title: title,
          children:
            do_construct_subgraph_tree(
              full_subgraph_list,
              Graphing.SubgraphReader.subgraphs(full_subgraph_list, id),
              people_list,
              [],
              id
            ),
          people: Graphing.People.people_contained_by(people_list, id)
        }
        | acc
      ],
      parent_id
    )
  end

  defp do_construct_subgraph_tree(
         full_subgraph_list,
         [[_id, _title, _contained_by] | tail],
         people_list,
         acc,
         parent_id
       ) do
    do_construct_subgraph_tree(full_subgraph_list, tail, people_list, acc, parent_id)
  end
end
```

```elixir
defmodule Relationship do
  defstruct source_id: 0,
            source_link: :open_link,
            destination_id: 0,
            destination_link: :open_link,
            description: ""
end
```

```elixir
defmodule Graphing.Relationships do
  def construct_relationship_tree(relationship_list) when is_list(relationship_list) do
    do_construct_relationship_tree(relationship_list, [])
  end

  defp do_construct_relationship_tree([], acc), do: acc

  defp do_construct_relationship_tree(
         [[source_id, destination_id, source_link, destination_link, description] | tail],
         acc
       ) do
    source_link =
      case source_link do
        "Open (no arrow)" -> :open_link
        "Arrow" -> :arrow
        "Dotted" -> :dotted
        "Dotted arrow" -> :dotted_arrow
        "Thick" -> :thick
        "Thick arrow" -> :thick_arrow
        "Circular node at end" -> :circular_terminator
        "X at end" -> :x_terminator
        _ -> :open_link
      end

    destination_link =
      case destination_link do
        "Open (no arrow)" -> :open_link
        "Arrow" -> :arrow
        "Dotted" -> :dotted
        "Dotted arrow" -> :dotted_arrow
        "Thick" -> :thick
        "Thick arrow" -> :thick_arrow
        "Circular node at end" -> :circular_terminator
        "X at end" -> :x_terminator
        _ -> :open_link
      end

    do_construct_relationship_tree(tail, [
      %Relationship{
        source_id: source_id,
        destination_id: destination_id,
        source_link: source_link,
        destination_link: destination_link,
        description: description
      }
      | acc
    ])
  end
end
```

```elixir
defmodule Graphing.DataTree do
  def construct_graph_tree(data_payload) when is_list(data_payload) do
    [
      {"People", [_people_headers | people_list]},
      {"Groupings", [_grouping_headers | groupings_list]},
      {"Relationships", [_relationship_headers | relationships_list]} | _
    ] = data_payload

    people_tree = Graphing.People.parse_people(people_list)

    %{
      people: people_tree,
      subgraphs:
        Graphing.Subgraphs.Tree.construct_subgraph_tree(
          groupings_list,
          people_tree
        ),
      relationships: Graphing.Relationships.construct_relationship_tree(relationships_list)
    }
  end
end
```

```elixir
defmodule Graphing.Mermaid do
  def generate_mermaid_from_tree(data_tree) when is_map(data_tree) do
    [
      Graphing.Mermaid.generate_mermaid_chart_preamble(),
      Graphing.Mermaid.generate_mermaid_from_people(data_tree.people),
      Graphing.Mermaid.generate_mermaid_from_subgraphs(data_tree.subgraphs),
      Graphing.Mermaid.generate_mermaid_from_relationships(data_tree.relationships)
    ]
    |> Enum.join(";")
  end

  def generate_mermaid_chart_preamble(direction \\ "TD") do
    "flowchart #{direction}"
  end

  def generate_mermaid_from_people(people_list) when is_list(people_list) do
    for person <- people_list do
      %Person{id: id, name: name, dob: dob} = person
      "#{to_string(id)}([\"`#{name}<br>#{Calendar.strftime(dob, "%d/%m/%Y")}`\"])"
    end
    |> Enum.join(";")
  end

  defp relationship_source_link(source_link) when is_atom(source_link) do
    case source_link do
      :arrow -> "<--"
      _ -> "--"
    end
  end

  defp relationship_destination_link(destination_link) when is_atom(destination_link) do
    case destination_link do
      :arrow -> "-->"
      _ -> "---"
    end
  end

  def generate_mermaid_from_relationships(relationship_list) when is_list(relationship_list) do
    for relationship <- relationship_list do
      %Relationship{
        source_id: source_id,
        source_link: source_link,
        destination_id: destination_id,
        destination_link: destination_link,
        description: description
      } = relationship

      case description do
        "" ->
          "#{source_id} #{relationship_destination_link(destination_link)} #{destination_id}"

        _ ->
          "#{source_id}#{relationship_source_link(source_link)} \"`#{description}`\" #{relationship_destination_link(destination_link)}#{destination_id}"
      end
    end
    |> Enum.join(";")
  end

  def generate_mermaid_from_subgraphs(subgraph_list) when is_list(subgraph_list) do
    do_mermaid_from_subgraph(subgraph_list, [])
    |> do_flatten_mermaid_subgraph
    |> do_filter_mermaid_subgraph
    |> do_join_mermaid_subgraph
  end

  defp do_flatten_mermaid_subgraph(""), do: nil

  defp do_flatten_mermaid_subgraph(subgraph_list) when is_list(subgraph_list) do
    List.flatten(subgraph_list)
  end

  defp do_filter_mermaid_subgraph(subgraph_list) when is_nil(subgraph_list), do: nil

  defp do_filter_mermaid_subgraph(subgraph_list) when is_list(subgraph_list) do
    Enum.filter(subgraph_list, fn i -> i != "" end)
  end

  defp do_join_mermaid_subgraph(subgraph_list) when is_nil(subgraph_list), do: nil

  defp do_join_mermaid_subgraph(subgraph_list) when is_list(subgraph_list) do
    Enum.join(subgraph_list, " ")
  end

  def do_mermaid_from_subgraph([], []), do: ""
  def do_mermaid_from_subgraph([], acc), do: acc

  def do_mermaid_from_subgraph(
        [
          %Subgraph{
            id: id,
            title: title,
            children: children_list,
            people: people_list
          }
          | tail
        ],
        acc
      ) do
    do_mermaid_from_subgraph(tail, [
      "subgraph #{id} [\"`#{title}`\"];",
      Graphing.Mermaid.do_mermaid_from_subgraph(children_list, []),
      Graphing.Mermaid.generate_mermaid_subgraph_people(people_list),
      "end " | acc
    ])
  end

  def generate_mermaid_subgraph_people(people_list) when is_list(people_list) do
    people_mermaid =
      for person <- people_list do
        %Person{id: id} = person
        "#{to_string(id)}"
      end
      |> Enum.join(";")

    case people_mermaid do
      "" -> ""
      _ -> people_mermaid <> ";"
    end
  end
end
```

## Generating the Mermaid Graph

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_spreadsheet = Kino.Input.file("Please select your input spreadsheet")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
value = Kino.Input.read(input_spreadsheet)
```

```elixir
Kino.Markdown.new("""
### Instructions for use

1. Select your file above
1. Click the '_play_' button that appears in the bottom right-hand corner to generate the diagram
1. Immediately below these instructions, you will quickly see a draft diagram drawn; check all information is presented and correct
1. Underneath the diagram, you will see the chart code. Copy this code in its entirety, this will generate your diagram
""")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
mermaid_graph =
  case value do
    nil ->
      nil

    _ ->
      Kino.Input.file_path(value.file_ref)
      |> Graphing.Spreadsheet.open_spreadsheet_file()
      |> Graphing.Spreadsheet.read_all_worksheets()
      |> Graphing.DataTree.construct_graph_tree()
      |> Graphing.Mermaid.generate_mermaid_from_tree()
  end
```

## Mermaid graph generator

```elixir
case mermaid_graph do
  nil -> nil
  _ -> Kino.Mermaid.new(mermaid_graph)
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Markdown.new(mermaid_graph)
```
